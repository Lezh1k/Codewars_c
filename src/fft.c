/* ****************** FFT ****************** */
#include <assert.h>
#include <complex.h>
#include <stdbool.h>
#include <stdint.h>

///////////////////////////////////////////////////////
static bool fft(complex float *dat, int32_t N,
                int32_t LogN, bool inv);

#define MAX_LOG2_N 32
static double RCoef[MAX_LOG2_N] = {
  -1.00000000000000000000000000, 0.00000000000000006123233996, 0.70710678118654757273731093,
  0.92387953251128673848313611, 0.98078528040323043057924224, 0.99518472667219692873175063,
  0.99879545620517240500646494, 0.99969881869620424996725205, 0.99992470183914450299056398,
  0.99998117528260110908888691, 0.99999529380957619117964441, 0.99999882345170187925020855,
  0.99999970586288222662574299, 0.99999992646571789212117665, 0.99999998161642933425241608,
  0.99999999540410733356310402, 0.99999999885102686114635162, 0.99999999971275665977543667,
  0.99999999992818922045501040, 0.99999999998204724960260137, 0.99999999999551181240065034,
  0.99999999999887800861131382, 0.99999999999971944664167722, 0.99999999999992983390484369,
  0.99999999999998245847621092, 0.99999999999999567013020396, 0.99999999999999888977697537,
  0.99999999999999977795539507, 0.99999999999999988897769754, 1.00000000000000000000000000,
  1.00000000000000000000000000, 1.00000000000000000000000000
};

static double ICoef[MAX_LOG2_N] = {
  0.00000000000000012246467991, 1.00000000000000000000000000, 0.70710678118654746171500847,
  0.38268343236508978177923268, 0.19509032201612824808378832, 0.09801714032956060362877793,
  0.04906767432741801493456535, 0.02454122852291228812360302, 0.01227153828571992538742919,
  0.00613588464915447526909498, 0.00306795676296597614324257, 0.00153398018628476550014039,
  0.00076699031874270448549957, 0.00038349518757139556320718, 0.00019174759731070329152845,
  0.00009587379909597734466923, 0.00004793689960306688130961, 0.00002396844980841821931778,
  0.00001198422490506970529769, 0.00000599211245264242752721, 0.00000299605622633466083516,
  0.00000149802811316901114271, 0.00000074901405658471574140, 0.00000037450702829238412872,
  0.00000018725351414619534661, 0.00000009362675707309808359, 0.00000004681337853654908812,
  0.00000002340668926827455068, 0.00000001170334463413727699, 0.00000000585167231706863850,
  0.00000000292583615853431925, 0.00000000146291807926715962
};
//////////////////////////////////////////////////////////////////////////

#define  NUMBER_IS_2_POW_K(x)   ((!((x)&((x)-1)))&&((x)>1))  // x is pow(2, k), k=1,2, ...

bool fft(complex float *dat, int32_t N, int32_t LogN, bool inv) {
  // parameters error check:
  assert(dat);
  assert(NUMBER_IS_2_POW_K(N));
  assert(LogN >= 2 && LogN <= MAX_LOG2_N);

  int32_t i, j, n, io, ie, in, nn;
  complex float tp, tq;
  ie = N; //N для каждого из уровней. для первого N. Для второго N/2 и т.д.
  for(n=1; n<=LogN; ++n) {
    //rw и iw - поворотный коэффициент для LogN.
    //w = -2.0 * M_PI / pow(2.0, n)
    complex float w = {RCoef[LogN - n], ICoef[LogN - n]};
    if(inv)
      w = conj(w);
    in = ie >> 1; //in - середина... N/2 для каждого уровня.
    //u - используемый поворотный коэффициент
    complex float u = 1.0;
    for(j=0; j<in; ++j) {
      for(i=j; i<N; i+=ie) {
        io = i + in; //io = i + N/2 для каждого из уровней...

        //s(2k) = s0(k) + s1(k)
        tp = dat[i] + dat[io];
        //s0(k) - s1(k)
        tq = dat[i] - dat[io];
        //s(2k+1) = Wkn * (s0(k) - s1(k))
        dat[io] = tq * u;
        dat[i] = tp;
      }
      //Wk+1 = W*Wk
      u *= w;
    }

    ie >>= 1;
  }
  //граф бабочка для всех уровней здесь уже завершен. дальше должна быть перестановка.

  //nn = N/2
  //bit-reversal permutation :)
  nn = N >> 1;
  for(j=i=1; i<N; ++i) {
    if(i < j) {
      //swap dat[io] and dat[in].
      io = i - 1;
      in = j - 1;
      tp = dat[in];
      dat[in] = dat[io];
      dat[io] = tp;
    }

    int32_t k = nn;
    while(k < j) {
      j = j - k;
      k >>= 1;
    }

    j = j + k;
  }
  //перестановка завершена

  if(!inv)
    return true;

  for(i=0; i<N; ++i) {
    dat[i] /= (double)N;
  }
  return true;
}
//////////////////////////////////////////////////////////////////////////
/* ****************** FFT END *******************/
